# CREATE USER 'gprom'@'%' IDENTIFIED VIA mysql_native_password USING 'miller';
# GRANT USAGE ON *.* TO 'gprom'@'%' REQUIRE NONE WITH MAX_QUERIES_PER_HOUR 0 MAX_CONNECTIONS_PER_HOUR 0 MAX_UPDATES_PER_HOUR 0 MAX_USER_CONNECTIONS 0;
# GRANT ALL PRIVILEGES ON `gprom`.* TO 'gprom'@'%';

#########################
# Касательно таблиц отмечаю, что недоступный в текущей MariaDB формат поля @время-без-часового-пояса@ убран.
# id трансформируется в целочисленный 12 (пока хватит), хотя при наличии внутреннего идентификатора, 
# используемого в двух таблицах - поле представляется мне избыточным, разве что ради ускорения связывания таблиц через целое число.
# Я предпочёл бы конвертировать внутренний ИД в целочисленный при парсинге и сделать это число межтабличным ключом, 
# но утратится _ЛЁГКАЯ_ возможность вручную сличить файл лога c содержимым БД. Ненужная на мой взгляд.
# Оставляю как есть лишь ради точности исполнения ТЗ. 
#######
# Булево поле для статуса трансформировано в синоним  TINYINT(1) - однобайтное целочисленное, 
# ради пущей ясности назначения поля.
#######
# Что касается констрайнта с именованием индекса, то моя MariaDB игнорирует присвоение имени 
# для первичного ключа на этапе создания, однако обращение к нему по этому имени остаётся возможным.
########################

CREATE TABLE message (
created TIMESTAMP(0) NOT NULL,
id int(12) NOT NULL AUTO_INCREMENT,
int_id CHAR(16) NOT NULL,
str VARCHAR(4096) NOT NULL,
status TINYINT(1) UNSIGNED,
CONSTRAINT message_id_pk PRIMARY KEY(id)
);


CREATE INDEX message_created_idx ON message (created);
CREATE INDEX message_int_id_idx ON message (int_id);


#########################
# Моя версия марииДБ требует указания опции хеш-индекса USING hash перед указанием поля, по которому индекс строить,
# Также ей хочется явного указания движка хранения после определения полей.
#####
# Кроме прочего, не могу согласиться с избыточным хранением полной строки лога в двух таблицах.
# Я предпочёл бы создать представление либо джойнить таблицы, только когда полная строка 
# реально требуется при детальном просмотре уже найденного.
#####
# Допуская, что дублирование может потребоваться ради неких хитрых разграничений при выборке, 
# следую ТЗ, хоть и с некоторым удивлением:
########################



CREATE TABLE log (
created TIMESTAMP(0) NOT NULL,
int_id VARCHAR(16) NOT NULL,
str VARCHAR(4096),
address VARCHAR(64)
) ENGINE = MEMORY;

CREATE INDEX log_address_idx USING hash ON log (address);
