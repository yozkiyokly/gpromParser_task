# package Exim_log parser;

sub parse_maillog_file($$){      			# прототип - 2 скаляра.
my ($filename,$dbHandler)= @_;   			#--OTLaDka:--# print " dbHandler = $dbHandler \nФайл для парсинга: $filename<br>";

open ($filehandle, "<", $filename) or die "could not open $filename for parsing";
while (my $line = readline($filehandle)) { 	#--OTLaDka:--# print "<small><font color=grey>" .$line."</font></small>:";

########## Многострочный регексп с комментариями
# вначале откусим от лога дату. Она занимает 19 байт плюс пробел. После этого в логе будут разночтения.
# не будем тошнить точностью поиска \d{4}(?:-\d{2}(?:-\d{2}(?: \d{2}(?::\d{2}(?::\d{2})?)?)?)?)?
# а тупо резанём 19 циферок, минусиков и двоеточиев и пробелов.
# Вот так: (^[0-9-:\s]{19})
my @parseBasic= $line =~ /(^[0-9-:\s]{19})
####
# затем следует выковырять внутренний ID. Пока по логу не видно, предусмотрено ли увеличение разрядности.
# презюмирую, что разрядность не будет расширяться и ограничиваю парсинг фиксированной структурой,
# содержащей дефисы на конкретных позициях и находящейся \bвнутри\b "слова". 1Rm0kE-00027I-IY
# ради темпа обработки не делаю проверку на маловерояное несодержание @,
# но так и быть, ограничиваю набор знаков через \w
#           \b\w{6}-\w{6}-\w{2}\b|  			^^^ спокойствия для:

\s(\w{6}-\w{6}-\w{2})\b/sx;   				#--OTLaDka:--#  print 'datetime:'. @parseBasic[0];

# Очередь вытрясти флаг. Дальше его наличие будет являться признаком участия записи в поиске.
# Строка лога может (!) содержать более одного "флага",
# поэтому пришлось нашинковать красивый длинный регексп на малые.
# Цитируем такой случай из лога:
############
# 	2012-02-13 14:39:22 1RwtJa-000AGs-7A <= <> R=1Rm0kE-00027I-IY U=mailnull P=local S=2551
############  							 ^^-^^---ВОТ, бывает.
# При отсутствии флага цикл функции будет оборван, чтобы перейти к следующей строке без задержки.
# Да, можно конкретизировать набор четырьмя вариантами начертания, но:
# Дело в том, что лог содержит также пустые отчёты о подключениях к SMTP,
# отчёты о завершённых делэях и даже матюги насчёт доступа ексима к файловой системе.
# Полезных данных такие строки будто бы не содержат; стало быть и пихать их в БД незачем.
# Отметим и этот факт цитатой из лога:
##########################
#	2012-02-13 14:40:34 1RwtJT-0009RI-Gl Completed
#	2012-02-13 14:40:35 1RwtEr-0002zL-NQ Spool file is locked (another process is handling this message)
#	2012-02-13 14:40:35 SMTP connection from [194.226.65.146] (TCP/IP connection count = 1)
##########################
# Да, можно конкретизировать набор четырьмя вариантами начертания, 
# но в пустопорожних строках лога пока не замечено ничего, 
# что было бы достойно затраты этой микросекунды.
# Впрочем, в дистрибуционной версии пустопорожние строки будут возвращены в лог как опция,
# если кто-то захочет разобраться с блокировкой спула

my @flag= $line =~ /([=><*]{2})/s;

if (@flag[0]){ 		#Если флаг вообще имеет место, тогда вставляем в таблицы всё что напарсилось:
#флаг - в число:
	if 		(@flag[0] eq "<="){$flag=1;}	#incoming
	elsif	(@flag[0] eq "=>"){$flag=2;}	#outgoing	
	elsif	(@flag[0] eq "=="){$flag=3;}	#delayed
	elsif	(@flag[0] eq "**"){$flag=4;}	#stalled

# Дерём первый встретившийся email. 
# Это вариант regexp без бюрократического соблюдения RFC-5322, как у emailregex.com, но работает.
# Массив содержит в ячейках все адреса, найденные в строке.
my @email= $line =~ /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b/gs;

# вырезаем и остаток строки от завершения первого вхождения флага:
my @log_string= $line =~ /[=><*]{2}\s(.*)$/s;

#TODO: Вывести в модуль все операции с БД, 
#иначе замучаемся с альтернативными движками доступа к данным:
require './DatabaseRequests.pm'; 

if (@email[0]&&!insert_both_tables @parseBasic[0],@parseBasic[1],@log_string[0],@email[0],$flag,$dbHandler){last;return ($inserts,$totalStringsParsed);}
$inserts++; #Предпринято попыток вставки в БД
}else {$flag=0;} # just skip all lines where flag is absent.

$flag[0]='';
$totalStringsParsed++; # всего обработано строк.

}
# Конец парсинга. В счётчиках теперь есть два числа.
# файл можно закрывать, затем выплёвывать наружу счётчики:
close  $filehandle;
return ($inserts,$totalStringsParsed);
}

return true;
